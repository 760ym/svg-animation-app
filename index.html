<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Animation App</title>
  <style>
    svg {
      border: 1px solid black;
      user-select: none;
    }
    .player {
      cursor: pointer;
      fill-opacity: 0.8;
    }
    .player-text {
      font-size: 12px;
      text-anchor: middle;
      alignment-baseline: middle;
      pointer-events: none;
    }
    .timeline {
      display: flex;
      justify-content: center;
      margin-top: 10px;
    }
    .frame {
      width: 20px;
      height: 20px;
      margin: 0 5px;
      cursor: pointer;
      background-color: lightgray;
      border: 1px solid #333;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .frame.active {
      background-color: gray;
    }
    .path-line {
      stroke: black;
      stroke-width: 2;
    }
    .path-node {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <svg id="scene" width="800" height="600"></svg>
  <div class="timeline" id="timeline"></div>
  <button onclick="addFrame()">Add Frame</button>
  <button onclick="playAnimation()">Play Animation</button>
  <button onclick="startCreateAnimation()">Start Create Animation</button>

  <script>
    const svg = document.getElementById('scene');
    const timeline = document.getElementById('timeline');
    const teamColors = [
      'red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'brown', 'cyan', 'magenta'
    ];
    let frames = [];
    let currentFrameIndex = 0;

    function createTeams() {
      let y = 550; // Position at the bottom
      let teamSpacing = 80; // Spacing between teams

      teamColors.forEach((color, teamIndex) => {
        let x = 50 + teamIndex * teamSpacing; // Unique positions for each team
        for (let i = 0; i < 10; i++) { // Each team has 10 players
          createPlayer(x, y, color, i + 1);
        }
      });
    }

    function createPlayer(x, y, color, number) {
      const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      const player = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      player.setAttribute('cx', x);
      player.setAttribute('cy', y);
      player.setAttribute('r', 20);
      player.setAttribute('fill', color);
      player.classList.add('player');

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', x);
      text.setAttribute('y', y);
      text.classList.add('player-text');
      text.textContent = number;

      group.appendChild(player);
      group.appendChild(text);
      svg.appendChild(group);

      // Add drag-and-drop functionality
      let isDragging = false;
      let clone = null;
      let pathLine = null;
      let pathNodes = [];

      group.addEventListener('mousedown', (event) => {
        isDragging = true;
        clone = createClonePlayer(player, text);
        pathLine = createPathLine(player, clone);
        pathNodes = createPathNodes(pathLine);
        event.preventDefault();
      });

      svg.addEventListener('mousemove', (event) => {
        if (isDragging && clone) {
          const point = svg.createSVGPoint();
          point.x = event.clientX;
          point.y = event.clientY;
          const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());
          clone.setAttribute('cx', svgPoint.x);
          clone.setAttribute('cy', svgPoint.y);
          text.setAttribute('x', svgPoint.x);
          text.setAttribute('y', svgPoint.y);
          updatePathLine(pathLine, player, clone, pathNodes);
        }
      });

      svg.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          clone = null;
          pathLine = null;
          pathNodes.forEach(node => svg.removeChild(node));
          pathNodes = [];
        }
      });
    }

    function createClonePlayer(player, text) {
      const clone = player.cloneNode();
      clone.setAttribute('fill', player.getAttribute('fill'));
      svg.appendChild(clone);
      return clone;
    }

    function createPathLine(player, clone) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', player.getAttribute('cx'));
      line.setAttribute('y1', player.getAttribute('cy'));
      line.setAttribute('x2', clone.getAttribute('cx'));
      line.setAttribute('y2', clone.getAttribute('cy'));
      line.classList.add('path-line');
      svg.appendChild(line);
      return line;
    }

    function createPathNodes(line) {
      const nodes = [];
      for (let i = 0; i < 3; i++) {
        const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        node.setAttribute('cx', (parseFloat(line.getAttribute('x1')) + parseFloat(line.getAttribute('x2'))) / 2);
        node.setAttribute('cy', (parseFloat(line.getAttribute('y1')) + parseFloat(line.getAttribute('y2'))) / 2);
        node.setAttribute('r', 5);
        node.setAttribute('fill', 'black');
        node.classList.add('path-node');
        addNodeDragFunctionality(node, line);
        svg.appendChild(node);
        nodes.push(node);
      }
      return nodes;
    }

    function updatePathLine(line, player, clone, nodes) {
      line.setAttribute('x1', player.getAttribute('cx'));
      line.setAttribute('y1', player.getAttribute('cy'));
      line.setAttribute('x2', clone.getAttribute('cx'));
      line.setAttribute('y2', clone.getAttribute('cy'));
      nodes.forEach((node, index) => {
        node.setAttribute('cx', (parseFloat(line.getAttribute('x1')) + parseFloat(line.getAttribute('x2'))) / 2);
        node.setAttribute('cy', (parseFloat(line.getAttribute('y1')) + parseFloat(line.getAttribute('y2'))) / 2);
      });
    }

    function addNodeDragFunctionality(node, line) {
      let isNodeDragging = false;

      node.addEventListener('mousedown', (event) => {
        isNodeDragging = true;
        event.preventDefault();
      });

      svg.addEventListener('mousemove', (event) => {
        if (isNodeDragging) {
          const point = svg.createSVGPoint();
          point.x = event.clientX;
          point.y = event.clientY;
          const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());
          node.setAttribute('cx', svgPoint.x);
          node.setAttribute('cy', svgPoint.y);
          updatePathLineWithNodes(line);
        }
      });

      svg.addEventListener('mouseup', () => {
        isNodeDragging = false;
      });
    }

    function updatePathLineWithNodes(line) {
      // Update the path line with the positions of the nodes
      // This function needs to be implemented to adjust the path line based on node positions
    }

    function addFrame() {
      const frame = {
        players: Array.from(svg.querySelectorAll('.player')).map(player => {
          return {
            cx: player.getAttribute('cx'),
            cy: player.getAttribute('cy'),
            fill: player.getAttribute('fill'),
            number: player.nextSibling.textContent
          };
        })
      };
      frames.push(frame);
      renderTimeline();
    }

    function renderTimeline() {
      timeline.innerHTML = '';
      frames.forEach((frame, index) => {
        const frameElement = document.createElement('div');
        frameElement.classList.add('frame');
        if (index === currentFrameIndex) {
          frameElement.classList.add('active');
        }
        frameElement.textContent = index + 1;
        frameElement.addEventListener('click', () => {
          loadFrame(index);
        });
        timeline.appendChild(frameElement);
      });
    }

    function loadFrame(index) {
      currentFrameIndex = index;
      const frame = frames[index];
      svg.innerHTML = '';
      frame.players.forEach(playerData => {
        createPlayer(playerData.cx, playerData.cy, playerData.fill, playerData.number);
      });
      renderTimeline();
    }

    function playAnimation() {
      let frameIndex = 0;
      const interval = setInterval(() => {
        if (frameIndex >= frames.length) {
          clearInterval(interval);
          return;
        }
        loadFrame(frameIndex);
        frameIndex++;
      }, 1000); // Change frame every 1000ms
    }

    function startCreateAnimation() {
      createTeams();
      addFrame(); // Add initial frame
    }

    startCreateAnimation(); // Start automatically
  </script>
</body>
</html>
